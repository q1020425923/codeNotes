算法：
1.冒泡排序 基本
从头开始循环，每相邻两数比较，把最大的数往最后推，所以必然能得到最大值。
之后每次减少一次循环，因为最大值已经出来了
冒泡排序 优化一
设一个flag，初始为true，if比较里面赋为false，如果没走就是顺序提前对了，走了就是还没对。
冒泡排序 优化二
记录最后的交换下标，最后下标后面的都未交换，所以是正确顺序的，后面从第一个循环到下标处即可。
冒泡排序 优化三
在二的基础上加一遍从后往前的循环，确定最小值交换下标，这样之后循环起点位置也从最小值下标开始。

2.快速排序 基本
下标     0,1,2,3,4
         k       
数组a = [2,4,6,1,3];
1.i取头下标，j取尾下标，k存头值
i = 0;
j = 4;
k = 2;
2.从j位递减找，<=2的数，找到后a[j]和a[i]的值换位，更新j值
         <=  j
下标     0,1,2,3,4
               k
数组a = [1,4,6,2,3];
i = 0;
j = 3;
k = 2;
3.从i递加找，>=2的数，找到后a[i]和a[j]的值换位，更新i值
         => i
下标     0,1,2,3,4
           k    
数组a = [1,2,6,4,3];
i = 1;
j = 3;
k = 2;
4.从j位递减找，<=2的数，找到后a[j]和a[i]的值换位，更新j值
         <=  j
下标     0,1,2,3,4
           k    
数组a = [1,2,6,4,3];
i = 1;
j = 1;
k = 2;
5.重复2,3直到a[i]==a[j]==k
此时k左边的数都比k小，k右边的数都比k大
6.再次对k左和k右进行 左右数组快速排序，直到分出的数组中只有一个数，不能再分为止。最后得到正确结果。